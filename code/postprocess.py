'''Improve formatting of figures and tables generated by R code.'''

# pylint: disable=invalid-name

import sys
from typing import Sequence
import bs4

## == SVG POST-PROCESSING ================================================== ##


def postprocess_figure(source: str, destination: str):
    '''Prettify formatting of a plot SVG.

    Parameters
    ----------
    source: str
        Path to original SVG file.
    destination: str
        Path to save modifed file.
    '''
    text = None
    with open(source, 'r', encoding='utf-8') as file:
        text = file.read()

    text = _svg_italicize_species_names(text)
    text = _per_ml_to_inverse_ml(text)

    with open(destination, 'w', encoding='utf-8') as file:
        file.write(text)


def _svg_italicize_species_names(svg_text: str) -> str:
    '''Italicize all species names in a SVG.

    This function knows nothing about what an SVG is, it just
    is a fancy find-and-replace... so it will break things
    if the input has species names anywhere outside of a
    <text/> element.

    Parameters
    ----------
    svg_text: str
        Text contents of SVG file.

    Returns
    -------
    str
        Text contents of SVG file with all species names wrapped
        in a <tspan/> that italicizes them.
    '''

    return _wrap_all(text=svg_text,
                     words_to_wrap=_species_names,
                     before_part='<tspan style=\'font-style: italic\'>',
                     after_part='</tspan>')


## == HTML POST-PROCESSING ================================================= ##


def postprocess_table(name: str, source: str, destination: str, rearrange: bool):
    '''Prettify formatting of a table HTML file.

    Parameters
    ----------
    name: str
        Short name of table. One of ['1', '2', 'S1', 'S2', 'S3', 'S4', 'S5', 'CC'].
    source: str
        Path to original HTML file.
    destination: str
        Path to save modifed file.
    rearrange: bool
        Whether to rearrange tables to have a layout more like the one
        used in the manuscript. This mainly involves merging sub tables
        and putting their captions into a column.

    '''
    text = None
    with open(source, 'r', encoding='utf-8') as file:
        text = file.read()

    if rearrange:
        if name == '1':
            text = _html_rearrange_table_1(text)
        elif name == '2':
            text = _html_rearrange_table_2(text)
        elif name.upper() == 'S1':
            text = _html_rearrange_table_s1(text)
        elif name.upper() == 'S2':
            text = _html_rearrange_table_s2(text)
        elif name.upper() == 'S3':
            text = _html_rearrange_table_s3(text)
        elif name.upper() == 'S4':
            text = _html_rearrange_table_s4(text)
        elif name.upper() == 'S5':
            text = _html_rearrange_table_s5(text)
        elif name.upper() == 'CC':
            text = _html_rearrange_table_cc(text)
        else:
            raise ValueError('Unknown table name \'' + name + '\'.')

    text = _html_italicize_species_names(text)
    text = _per_ml_to_inverse_ml(text)

    with open(destination, 'w', encoding='utf-8') as file:
        file.write(text)


def _html_italicize_species_names(html_text: str) -> str:
    '''Italicize all species names in an HTML file.

    This function knows nothing about what HTML is, it just
    is a fancy find-and-replace... so it will break things
    if the input has species names anywhere unexpected.

    Parameters
    ----------
    svg_text: str
        Text contents of HTML file.


    Returns
    -------
    str
        Text contents of HTML file with all species names wrapped
        in a <i/> that italicizes them.
    '''

    return _wrap_all(text=html_text,
                     words_to_wrap=_species_names,
                     before_part='<i>',
                     after_part='</i>')


def _html_rearrange_table_1(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Table 1',
                            col_indices_of_data_cells_to_rotate=[0],
                            col_indices_of_headers_to_italicize=range(3, 9),
                            collapse_row_spans=True,
                            col_indices_to_bold_when_significant=range(2, 10),
                            col_index_significance_marker=9)


def _html_rearrange_table_2(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Table 2',
                            col_indices_of_data_cells_to_rotate=[0],
                            col_indices_of_headers_to_italicize=range(4, 7),
                            collapse_row_spans=True,
                            col_indices_to_bold_when_significant=range(2, 8),
                            col_index_significance_marker=7)


def _html_rearrange_table_s1(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Table S1',
                            col_indices_of_data_cells_to_rotate=[0],
                            col_indices_of_headers_to_italicize=range(3, 9),
                            collapse_row_spans=True,
                            col_indices_to_bold_when_significant=range(2, 10),
                            col_index_significance_marker=9)


def _html_rearrange_table_s2(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Table S2',
                            col_indices_of_data_cells_to_rotate=[0],
                            col_indices_of_headers_to_italicize=range(3, 8),
                            collapse_row_spans=True,
                            col_indices_to_bold_when_significant=range(2, 9),
                            col_index_significance_marker=8)


def _html_rearrange_table_s3(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Table S3',
                            col_indices_of_data_cells_to_rotate=[],
                            col_indices_of_headers_to_italicize=range(4, 6),
                            collapse_row_spans=False,
                            col_indices_to_bold_when_significant=range(0, 6),
                            col_index_significance_marker=5)


def _html_rearrange_table_s4(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Table S4',
                            col_indices_of_data_cells_to_rotate=[],
                            col_indices_of_headers_to_italicize=[],
                            collapse_row_spans=False,
                            col_indices_to_bold_when_significant=[],
                            col_index_significance_marker=None)


def _html_rearrange_table_s5(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Table S5',
                            col_indices_of_data_cells_to_rotate=[0],
                            col_indices_of_headers_to_italicize=range(6, 7),
                            collapse_row_spans=True,
                            col_indices_to_bold_when_significant=range(2, 8),
                            col_index_significance_marker=7)


def _html_rearrange_table_cc(html_text: str) -> str:
    return _rearrange_table(html_text=html_text,
                            title='Count Control Table',
                            col_indices_of_data_cells_to_rotate=[],
                            col_indices_of_headers_to_italicize=[],
                            collapse_row_spans=False,
                            col_indices_to_bold_when_significant=[],
                            col_index_significance_marker=None)


def _rearrange_table(html_text: str,
                     title: str,
                     col_indices_of_data_cells_to_rotate: Sequence,
                     col_indices_of_headers_to_italicize: Sequence,
                     collapse_row_spans: bool,
                     col_indices_to_bold_when_significant: Sequence,
                     col_index_significance_marker: int) -> str:
    html = bs4.BeautifulSoup(html_text)
    _set_title(html, title)
    table = html.table
    headers = table.thead.tr.find_all('th')
    # Make header bold.
    for header in headers:
        _set_tag_bold(header)

    # Italicize statistical symbols.
    for col_index in col_indices_of_headers_to_italicize:
        _set_tag_italic(headers[col_index])

    # Determine how (if at all) to merge variable/experiment cells
    # with identical values.
    VARIABLE_CELL_COLUMN = 0
    EXPERIMENT_CELL_COLUMN = 1

    rows = table.tbody.find_all('tr')
    variable_row_spans = []
    experiment_row_spans = []
    if collapse_row_spans:
        variable_row_spans = _find_row_spans(table, VARIABLE_CELL_COLUMN)
        experiment_row_spans = _find_row_spans(table, EXPERIMENT_CELL_COLUMN)
    else:
        table_row_count = len(rows)
        span_for_every_row = [range(i, i+1) for i in range(table_row_count)]
        variable_row_spans = span_for_every_row
        experiment_row_spans = span_for_every_row

    index_in_variable_row_spans = 0
    index_in_experiment_row_spans = 0
    for row_index, row in enumerate(rows):
        cells = row.find_all('td')
        variable_cell = cells[VARIABLE_CELL_COLUMN]
        experiment_cell = cells[EXPERIMENT_CELL_COLUMN]

        is_variable_span_start = False
        if index_in_variable_row_spans < len(variable_row_spans):
            is_variable_span_start = \
                variable_row_spans[index_in_variable_row_spans][0] == row_index
        is_experiment_span_start = False
        if index_in_experiment_row_spans < len(experiment_row_spans):
            is_experiment_span_start = \
                experiment_row_spans[index_in_experiment_row_spans][0] == row_index

        # Bold rows with significant p-value.
        if col_index_significance_marker is not None:
            sig_cell = cells[col_index_significance_marker]

            if '*' in sig_cell.string:
                for col_index in col_indices_to_bold_when_significant:
                    _set_tag_bold(cells[col_index])

        _set_tag_border(variable_cell, 'left')
        _set_tag_border(variable_cell, 'right')
        if is_variable_span_start:
            span = len(variable_row_spans[index_in_variable_row_spans])
            _set_tag_row_span(variable_cell, span)
            _set_tag_border(variable_cell, 'bottom')
        else:
            variable_cell.extract()

        if is_experiment_span_start:
            span = len(experiment_row_spans[index_in_experiment_row_spans])
            _set_tag_row_span(experiment_cell, span)
            _set_tag_border(experiment_cell, 'bottom')
        else:
            experiment_cell.extract()

        # If we are at the bottom of an experiment cell row span, give every
        # cell from the experiment cell rightward a bottom border. We also do
        # this in the case where there are no row spans.
        previous_index_in_experiment_row_spans = index_in_experiment_row_spans - 1
        if previous_index_in_experiment_row_spans < len(experiment_row_spans):
            last_row_span = experiment_row_spans[previous_index_in_experiment_row_spans]
            if row_index == last_row_span[-1] or not collapse_row_spans:
                # This is the last row from the previously encountered row span.
                # (Or, maybe more accurately, the row span we are still in but
                # had advanced the index past already.)
                for col_index in range(EXPERIMENT_CELL_COLUMN, len(cells)):
                    _set_tag_border(cells[col_index], 'bottom')

        for col_index in col_indices_of_data_cells_to_rotate:
            _set_tag_rotated(cells[col_index])

        _set_tag_border(cells[-1], 'right')

        if is_variable_span_start:
            index_in_variable_row_spans += 1
        if is_experiment_span_start:
            index_in_experiment_row_spans += 1

    return str(html)


def _find_row_spans(table: bs4.Tag,
                    col_index: int) -> list:
    '''List spans of rows in an HTML <table/> where cells in a column are identical.

    This function knows nothing about what a HTML is, it just
    is a fancy find-and-replace... so it will break things
    if the input has species names anywhere unexpected.

    Parameters
    ----------
    table: bs4.Tag
        Tag object representing the table

    col_index: int
        Index of column to look in.


    Returns
    -------
    list
        List of range objects holdign indices for each row span.
    '''
    rows = table.tbody.find_all('tr')
    last_contents = None
    last_start_row_index = 0
    row_span_ranges = []
    row_index = 0
    while row_index < len(rows):
        row = rows[row_index]
        cell = row.find_all('td')[col_index]
        contents = cell.contents
        if contents != last_contents:
            # Found start of new row span.
            if last_start_row_index != row_index:
                #  Avoid creating empty span at start of every table.
                row_span_ranges.append(range(last_start_row_index, row_index))

            last_contents = contents
            last_start_row_index = row_index
        row_index += 1

    # Add last row span in table, so long as table exists.
    if len(rows) > 0:
        row_span_ranges.append(range(last_start_row_index, row_index))

    return row_span_ranges


def _set_tag_bold(tag):
    _add_tag_style(tag, 'font-weight:bold;')


def _set_tag_italic(tag):
    _add_tag_style(tag, 'font-style: italic;')


def _set_tag_rotated(tag):
    _add_tag_style(tag, 'transform: rotate(-90deg);')


def _set_tag_border(tag, side: str):
    SIDES = ['left', 'right', 'top', 'bottom']
    if side not in SIDES:
        raise ValueError('Unexpected cell side: ' + str(side))

    BORDER_STYLE = '1px solid #000000'
    this_border = 'border-' + side + ': ' + BORDER_STYLE + ';'
    _add_tag_style(tag, this_border)


def _add_tag_style(tag, style: str):
    if len(tag['style']) > 0 and not tag['style'].endswith(';'):
        tag['style'] += '; '
    tag['style'] += style


def _set_tag_row_span(tag, span: int):
    tag['rowspan'] = str(span)


def _set_title(html_doc, title: str):
    title_tag = html_doc.head.title
    title_tag.string.replace_with(title)


## == QUERYING PYTHON SETUP ================================================ ##


def python_version() -> str:
    '''Get version of Python being used.'''
    return sys.version


## == GENERAL FUNCTIONS ==================================================== ##
_species_names = ['D. excentricus', 'L. pictus']


def _per_ml_to_inverse_ml(svg_text: str) -> str:
    '''Replace '/ml' with ml^-1 in an HTML or SVG file.

    This function knows nothing about what HTML or SVG are,
    it just is a fancy find-and-replace... so it will break
    things if the input has '/ml' anywhere unexpected.

    Parameters
    ----------
    svg_text: str
        Text contents of an HTML or SVG file.

    Returns
    -------
    str
        Text contents of SVG file with all instances of '/ml'
        rewritten as ' ml&#8315;&#185;' (HTML entitites for
        superscript '-1')
    '''
    return svg_text.replace('/ml', ' ml&#8315;&#185;')


def _wrap_all(text: str, words_to_wrap: list, before_part: str, after_part: str) -> str:
    for word in words_to_wrap:
        text = text.replace(
            word,
            before_part + word + after_part)

    return text
